DMP
=====================================

# 概要
このパッケージは、Dynamic Movement Primitives（DMP）の一般的な実装を提供します。 ここではDMPに関する優れたリファレンスを見つけることができますが、このパッケージはDMPのより安定した再構成を実装しており、これも参考文献に記載されています。 現在の機能には、サンプル軌道からの多次元DMPの学習、任意の開始点と目標点のための完全かつ部分的な計画の生成が含まれます。 最終的には、強化学習のネイティブサポートに加えて、より広い範囲の関数近似が追加されます。

1. この実装は、DMPによって生成されているもの、すなわち、力、加速、またはその他の量には無関心です。

2. 上記の論文のように、N次元のDMPをN個の別個のDMPとして単相システムにリンクして実装します。

3. 関数近似は簡単な局所線形補間スキームで行われるが、フーリエ基底を用いた大域関数近似器のコードも、ラジアル基底関数を用いた追加の局所近似スキームとともに提供される。 ただし、ロボットがローカルに完全に格納されるべきではない大量のデータから学習している場合を除き、線形補間を使用することをお勧めします。

# パラメータ
DMPには、学習と計画の両方にいくつかの説明が必要ないくつかのパラメータがあります。

## LearnDMPFromDemo
* k_gains: これは、DMPの各寸法に対する比例ゲイン（基本的にばね定数）のリストです。 これらは非常に柔軟に設定でき、それでも動作します。 値100は、通常、PR2を制御するために働きます。

* d_gains: これは、DMPの各ディメンションの減衰ゲインのリストです。 これらは、ほとんど常にクリティカルダンピング（D = 2 * sqrt（K））のために設定する必要があります。

* num_bases: 使用する基底関数の数です（線形補間に基づく関数近似には適用されません）。 より複雑な非線形関数はより多くの基底を必要としますが、あまりに多くはオーバーフィットを引き起こす可能性があります（ただし、所望の軌道がデモ軌道と同じ長さであれば問題ありません;タウが変更された場合にのみ問題になります）。 また、通常は200以上の基底関数を使うべきではありません。あるいは物事はかなり減速し始めます。

## GetDMPPlan
* x_0: 計画を開始する開始状態。区分的計画/再計画を実行する場合は、生成された各計画の現在の状態に設定する必要があります。
* x_dot_0: 計画を開始する状態の1次導関数。
* t_0: 計画を開始するまでの時間（秒単位）。区分的な計画をしない限り、通常は0です。
* goal: DMPが収束すべき目標。
* goal_thresh: seg_lengthを先に計画している場合を除き、計画を停止する前にプランが入って来なければならない各ディメンションのしきい値。
* seg_length: 計画セグメントの長さ（秒単位）。これは、区分的で段階的な計画と再計画を行うために使用できます。それ以外の場合は、コンバージェンスが必要になるまで計画する場合は-1に設定します。
* tau: これは、現在生成されているセグメントだけでなく、秒単位で生成されたDMP全体の望ましい長さとして解釈できます。通常、デモンストレーションと同じ速度で実行したい場合は、LearnDMPFromDemoが返すタウの値を使用します。さもなければ、関数近似器が一般化/補間しなければならないので、それに応じてタウをスケールするが、性能が低下する可能性がある。
* dt: 計画の時間分解能（秒単位）
* integrate_iter: 加速度を速度に変更して位置に合わせるときに数値的に積分する回数。これは、dtがかなり大きい（すなわち、1秒より大きい）場合を除いて、通常は1にすることができる。

# ROSノード
## dmp_server
### Services
* learn_dmp_from_demo (LearnDMPFromDemo)
デモンストレーション軌道とDMPパラメータが与えられると、学習した多次元DMPを返します。  

* set_active_dmp (SetActiveDMP)
計画に使用されるアクティブな多次元DMPを設定します。

* get_dmp_plan (GetDMPPlan)
現在アクティブなDMPを使用して、開始状態から目標状態に完全または部分的な計画を作成します。
